# ä¸¦è¡Œåˆ¶å¾¡ã¨åœ¨åº«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ

**Document Version:** 1.0
**Created:** 2025-01-25
**Author:** Claude & Development Team
**Project:** Food Delivery Server (Bun + TypeScript + Prisma)

---

## ğŸ“‹ ç›®æ¬¡

1. [ç¾åœ¨ã®çŠ¶æ³](#1-ç¾åœ¨ã®çŠ¶æ³)
2. [å•é¡Œã®åŸå› åˆ†æ](#2-å•é¡Œã®åŸå› åˆ†æ)
3. [è§£æ±ºæ–¹æ¡ˆ](#3-è§£æ±ºæ–¹æ¡ˆ)
4. [å­¦ç¿’çŸ¥è­˜ç‚¹](#4-å­¦ç¿’çŸ¥è­˜ç‚¹)
5. [å®Ÿè£…è¨ˆç”»](#5-å®Ÿè£…è¨ˆç”»)

---

## 1. ç¾åœ¨ã®çŠ¶æ³

### 1.1 ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦

å½“ãƒ•ãƒ¼ãƒ‰ãƒ‡ãƒªãƒãƒªãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã¯ä»¥ä¸‹ã®æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã§æ§‹ç¯‰ã•ã‚Œã¦ã„ã¾ã™ï¼š

- **Backend:** Bun + Express + TypeScript
- **Database:** PostgreSQL + Prisma ORM
- **Architecture:** å˜ä½“ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆMonolithicï¼‰
- **Environment:** é–‹ç™ºç’°å¢ƒï¼ˆå˜ä¸€ã‚µãƒ¼ãƒãƒ¼ï¼‰

### 1.2 ç¾åœ¨ã®ã‚«ãƒ¼ãƒˆæ©Ÿèƒ½

```typescript
// src/services/cartService.ts ã®ä¸»è¦æ©Ÿèƒ½
class CartService {
  - findOrCreateUserCart()     // ã‚«ãƒ¼ãƒˆæ¤œç´¢ãƒ»ä½œæˆ
  - addFoodToCart()           // å•†å“è¿½åŠ 
  - updateCartItemQuantity()  // æ•°é‡æ›´æ–°
  - removeCartItem()          // ã‚¢ã‚¤ãƒ†ãƒ å‰Šé™¤
  - clearUserCart()           // ã‚«ãƒ¼ãƒˆã‚¯ãƒªã‚¢
}
```

### 1.3 ç¾åœ¨ã®æ³¨æ–‡ä½œæˆãƒ—ãƒ­ã‚»ã‚¹

```typescript
// src/services/orderService.ts ã® createOrderFromCart
1. ã‚«ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿å–å¾—
2. ã‚«ãƒ¼ãƒˆç©ºãƒã‚§ãƒƒã‚¯
3. ç·é¡è¨ˆç®—
4. æ³¨æ–‡ä½œæˆ
5. æ³¨æ–‡ã‚¢ã‚¤ãƒ†ãƒ ä½œæˆ
6. ã‚«ãƒ¼ãƒˆã‚¯ãƒªã‚¢
```

### 1.4 è­˜åˆ¥ã•ã‚ŒãŸåˆ¶é™äº‹é …

- âœ… åŸºæœ¬çš„ãªCRUDæ“ä½œã¯å®Ÿè£…æ¸ˆã¿
- âŒ ä¸¦è¡Œã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ãªã—
- âŒ åœ¨åº«ç®¡ç†æ©Ÿèƒ½ãªã—
- âŒ ç«¶åˆçŠ¶æ…‹å¯¾ç­–ãªã—
- âŒ åœ¨åº«ä¸è¶³æ¤œè¨¼ãªã—

---

## 2. å•é¡Œã®åŸå› åˆ†æ

### 2.1 ä¸¦è¡Œåˆ¶å¾¡å•é¡Œ

#### 2.1.1 ç«¶åˆçŠ¶æ…‹ï¼ˆRace Conditionï¼‰

**ã‚·ãƒŠãƒªã‚ªä¾‹:**
```
æ™‚åˆ»  ãƒ¦ãƒ¼ã‚¶ãƒ¼A           ãƒ¦ãƒ¼ã‚¶ãƒ¼B           ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çŠ¶æ…‹
T1    ã‚«ãƒ¼ãƒˆã«å•†å“è¿½åŠ     ã‚«ãƒ¼ãƒˆã«å•†å“è¿½åŠ     åœ¨åº«: 10å€‹
T2    åœ¨åº«ãƒã‚§ãƒƒã‚¯(10å€‹)  åœ¨åº«ãƒã‚§ãƒƒã‚¯(10å€‹)  åœ¨åº«: 10å€‹
T3    8å€‹è³¼å…¥æ±ºå®š        5å€‹è³¼å…¥æ±ºå®š         åœ¨åº«: 10å€‹
T4    åœ¨åº«æ›´æ–°(2å€‹æ®‹)    åœ¨åº«æ›´æ–°(-3å€‹?)     ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆ!
```

#### 2.1.2 ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ã®å•é¡Œç‚¹

```typescript
// å•é¡Œã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹
static async addFoodToCart(userId: number, foodId: number, quantity: number) {
    // ğŸš¨ å•é¡Œ: åœ¨åº«ãƒã‚§ãƒƒã‚¯ãªã—
    const food = await this.validateFoodAvailability(foodId);

    // ğŸš¨ å•é¡Œ: åŒæ™‚ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã®ç«¶åˆçŠ¶æ…‹
    const existingItem = await prisma.cartItem.findUnique(...);

    if (existingItem) {
        // ğŸš¨ å•é¡Œ: åŸå­æ€§ãªã—
        return await prisma.cartItem.update({
            data: { quantity: existingItem.quantity + quantity }
        });
    }
}
```

### 2.2 åœ¨åº«ç®¡ç†å•é¡Œ

#### 2.2.1 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆã®ä¸è¶³

**ç¾åœ¨ã®Foodãƒ†ãƒ¼ãƒ–ãƒ«:**
```sql
CREATE TABLE foods (
    id SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL,
    price DECIMAL NOT NULL,
    status BOOLEAN DEFAULT true,
    -- ğŸš¨ ç¼ºå°‘: stock INTEGER, -- åœ¨åº«æ•°é‡
    -- ğŸš¨ ç¼ºå°‘: reserved INTEGER, -- äºˆç´„æ¸ˆã¿æ•°é‡
    -- ğŸš¨ ç¼ºå°‘: version INTEGER -- æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ç”¨
);
```

#### 2.2.2 ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®ä¸è¶³

```typescript
// ç¾åœ¨ã®validateFoodAvailability
static async validateFoodAvailability(foodId: number) {
    const food = await prisma.food.findUnique({ where: { id: foodId } });

    // ğŸš¨ å•é¡Œ: statusã®ã¿ãƒã‚§ãƒƒã‚¯ã€åœ¨åº«æ•°é‡ãƒã‚§ãƒƒã‚¯ãªã—
    if (!food || !food.status) {
        return null;
    }
    return food;
}
```

### 2.3 ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç®¡ç†å•é¡Œ

#### 2.3.1 ä¸å®Œå…¨ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å¢ƒç•Œ

```typescript
// ç¾åœ¨ã®createOrderFromCart
static async createOrderFromCart(userId: number, orderRequest: CreateOrderRequest) {
    return await prisma.$transaction(async (tx) => {
        // âœ… ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½¿ç”¨
        const userCart = await CartService.getFullCartWithItems(userId);

        // ğŸš¨ å•é¡Œ: åœ¨åº«æ¸›ç®—ãªã—
        // ğŸš¨ å•é¡Œ: åœ¨åº«ä¸è¶³ãƒã‚§ãƒƒã‚¯ãªã—

        // æ³¨æ–‡ä½œæˆå‡¦ç†...
    });
}
```

---

## 3. è§£æ±ºæ–¹æ¡ˆ

### 3.1 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆã®æ”¹å–„

#### 3.1.1 Foodãƒ†ãƒ¼ãƒ–ãƒ«ã®æ‹¡å¼µ

```sql
-- åœ¨åº«ç®¡ç†ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è¿½åŠ 
ALTER TABLE foods ADD COLUMN stock INTEGER DEFAULT 0;
ALTER TABLE foods ADD COLUMN reserved INTEGER DEFAULT 0;
ALTER TABLE foods ADD COLUMN version INTEGER DEFAULT 1;
ALTER TABLE foods ADD COLUMN min_stock INTEGER DEFAULT 0;

-- åˆ¶ç´„ã®è¿½åŠ 
ALTER TABLE foods ADD CONSTRAINT check_stock_non_negative
    CHECK (stock >= 0);
ALTER TABLE foods ADD CONSTRAINT check_reserved_non_negative
    CHECK (reserved >= 0);
ALTER TABLE foods ADD CONSTRAINT check_stock_reserved_balance
    CHECK (stock >= reserved);
```

#### 3.1.2 åœ¨åº«å±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä½œæˆ

```sql
CREATE TABLE inventory_history (
    id SERIAL PRIMARY KEY,
    food_id INTEGER REFERENCES foods(id),
    change_type VARCHAR(20) NOT NULL, -- 'add', 'subtract', 'reserve', 'release'
    quantity INTEGER NOT NULL,
    previous_stock INTEGER NOT NULL,
    new_stock INTEGER NOT NULL,
    order_id INTEGER REFERENCES orders(id),
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    note TEXT
);

CREATE INDEX idx_inventory_history_food_id ON inventory_history(food_id);
CREATE INDEX idx_inventory_history_created_at ON inventory_history(created_at);
```

### 3.2 ä¸¦è¡Œåˆ¶å¾¡æˆ¦ç•¥

#### 3.2.1 æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ï¼ˆOptimistic Lockingï¼‰

```typescript
// æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ãŸåœ¨åº«æ›´æ–°
class InventoryService {
    static async updateStock(foodId: number, quantity: number, operation: 'add' | 'subtract') {
        const maxRetries = 3;
        let retries = 0;

        while (retries < maxRetries) {
            try {
                return await prisma.$transaction(async (tx) => {
                    // ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å•†å“å–å¾—
                    const food = await tx.food.findUnique({
                        where: { id: foodId }
                    });

                    if (!food) {
                        throw new Error('å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    }

                    const newStock = operation === 'add'
                        ? food.stock + quantity
                        : food.stock - quantity;

                    if (newStock < 0) {
                        throw new Error('åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
                    }

                    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯ä»˜ãã§æ›´æ–°
                    const updatedFood = await tx.food.updateMany({
                        where: {
                            id: foodId,
                            version: food.version
                        },
                        data: {
                            stock: newStock,
                            version: food.version + 1
                        }
                    });

                    // æ›´æ–°ã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ç«¶åˆç™ºç”Ÿ
                    if (updatedFood.count === 0) {
                        throw new Error('CONCURRENT_UPDATE');
                    }

                    // å±¥æ­´è¨˜éŒ²
                    await this.recordInventoryChange(tx, {
                        foodId,
                        changeType: operation,
                        quantity,
                        previousStock: food.stock,
                        newStock
                    });

                    return { success: true, newStock };
                });

            } catch (error) {
                if (error.message === 'CONCURRENT_UPDATE' && retries < maxRetries - 1) {
                    retries++;
                    // çŸ­æ™‚é–“å¾…æ©Ÿã—ã¦ãƒªãƒˆãƒ©ã‚¤
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
                    continue;
                }
                throw error;
            }
        }

        throw new Error('ä¸¦è¡Œæ›´æ–°ã®ç«¶åˆã«ã‚ˆã‚Šæ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
}
```

#### 3.2.2 æ‚²è¦³çš„ãƒ­ãƒƒã‚¯ï¼ˆPessimistic Lockingï¼‰

```typescript
// æ‚²è¦³çš„ãƒ­ãƒƒã‚¯ for é«˜ç«¶åˆã‚·ãƒŠãƒªã‚ª
class InventoryService {
    static async reserveStock(foodId: number, quantity: number) {
        return await prisma.$transaction(async (tx) => {
            // SELECT FOR UPDATE ã§è¡Œãƒ­ãƒƒã‚¯
            const food = await tx.food.findUnique({
                where: { id: foodId }
            });

            // PostgreSQL ã® FOR UPDATE æ§‹æ–‡ï¼ˆRaw SQLä½¿ç”¨ï¼‰
            const [lockedFood] = await tx.$queryRaw`
                SELECT * FROM foods
                WHERE id = ${foodId}
                FOR UPDATE
            `;

            const availableStock = lockedFood.stock - lockedFood.reserved;

            if (availableStock < quantity) {
                throw new Error(`åœ¨åº«ä¸è¶³: åˆ©ç”¨å¯èƒ½åœ¨åº« ${availableStock}å€‹`);
            }

            // äºˆç´„åœ¨åº«ã‚’å¢—åŠ 
            await tx.food.update({
                where: { id: foodId },
                data: {
                    reserved: lockedFood.reserved + quantity
                }
            });

            return {
                success: true,
                reservedQuantity: quantity,
                availableStock: availableStock - quantity
            };
        });
    }
}
```

### 3.3 æ”¹å–„ã•ã‚ŒãŸã‚«ãƒ¼ãƒˆã‚µãƒ¼ãƒ“ã‚¹

#### 3.3.1 åœ¨åº«ãƒã‚§ãƒƒã‚¯ä»˜ãã‚«ãƒ¼ãƒˆè¿½åŠ 

```typescript
class CartService {
    static async addFoodToCart(userId: number, foodId: number, quantity: number): Promise<CartItem> {
        return await prisma.$transaction(async (tx) => {
            // 1. å•†å“ã¨åœ¨åº«ã®æ¤œè¨¼
            const food = await this.validateFoodWithStock(foodId, quantity, tx);

            // 2. ã‚«ãƒ¼ãƒˆå–å¾—ãƒ»ä½œæˆ
            const cart = await this.findOrCreateUserCart(userId, tx);

            // 3. æ—¢å­˜ã‚¢ã‚¤ãƒ†ãƒ ãƒã‚§ãƒƒã‚¯
            const existingItem = await tx.cartItem.findUnique({
                where: {
                    cart_id_food_id: {
                        cart_id: cart.id,
                        food_id: foodId
                    }
                }
            });

            const newQuantity = existingItem
                ? existingItem.quantity + quantity
                : quantity;

            // 4. æœ€çµ‚åœ¨åº«ãƒã‚§ãƒƒã‚¯
            await this.validateFinalStock(foodId, newQuantity, tx);

            // 5. ã‚«ãƒ¼ãƒˆã‚¢ã‚¤ãƒ†ãƒ æ›´æ–°
            if (existingItem) {
                return await tx.cartItem.update({
                    where: { id: existingItem.id },
                    data: { quantity: newQuantity }
                });
            } else {
                return await tx.cartItem.create({
                    data: {
                        cart_id: cart.id,
                        food_id: foodId,
                        quantity: quantity
                    }
                });
            }
        });
    }

    private static async validateFoodWithStock(
        foodId: number,
        quantity: number,
        tx: any
    ): Promise<Food> {
        const food = await tx.food.findUnique({
            where: { id: foodId }
        });

        if (!food || !food.status) {
            throw new Error('å•†å“ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹åˆ©ç”¨ã§ãã¾ã›ã‚“');
        }

        const availableStock = food.stock - food.reserved;
        if (availableStock < quantity) {
            throw new Error(
                `åœ¨åº«ä¸è¶³ã§ã™ã€‚åˆ©ç”¨å¯èƒ½åœ¨åº«: ${availableStock}å€‹ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: ${quantity}å€‹`
            );
        }

        return food;
    }
}
```

### 3.4 æ³¨æ–‡ä½œæˆãƒ—ãƒ­ã‚»ã‚¹ã®æ”¹å–„

#### 3.4.1 åœ¨åº«äºˆç´„ã‚·ã‚¹ãƒ†ãƒ 

```typescript
class OrderService {
    static async createOrderFromCart(
        userId: number,
        orderRequest: CreateOrderRequest
    ): Promise<OrderData> {
        return await prisma.$transaction(async (tx) => {
            // 1. ã‚«ãƒ¼ãƒˆå–å¾—
            const userCart = await CartService.getFullCartWithItems(userId);

            if (!userCart.cart_items.length) {
                throw new Error('ã‚«ãƒ¼ãƒˆãŒç©ºã§ã™');
            }

            // 2. åœ¨åº«äºˆç´„ï¼ˆåŸå­çš„æ“ä½œï¼‰
            const reservationResults = await Promise.all(
                userCart.cart_items.map(item =>
                    InventoryService.reserveStock(
                        item.food_id,
                        item.quantity,
                        tx
                    )
                )
            );

            try {
                // 3. æ³¨æ–‡ä½œæˆ
                const totalAmount = userCart.cart_items.reduce((sum, item) => {
                    return sum + (item.food.price * item.quantity);
                }, 0);

                const order = await tx.order.create({
                    data: {
                        user_id: userId,
                        total_amount: totalAmount,
                        delivery_address: orderRequest.delivery_address,
                        phone: orderRequest.phone,
                        notes: orderRequest.notes,
                        status: OrderStatus.PENDING
                    }
                });

                // 4. æ³¨æ–‡ã‚¢ã‚¤ãƒ†ãƒ ä½œæˆ
                await Promise.all(
                    userCart.cart_items.map(item =>
                        tx.orderItem.create({
                            data: {
                                order_id: order.id,
                                food_id: item.food_id,
                                quantity: item.quantity,
                                price: item.food.price
                            }
                        })
                    )
                );

                // 5. äºˆç´„ã‚’ç¢ºå®šï¼ˆåœ¨åº«æ¸›ç®—ï¼‰
                await Promise.all(
                    userCart.cart_items.map(item =>
                        this.confirmReservation(item.food_id, item.quantity, order.id, tx)
                    )
                );

                // 6. ã‚«ãƒ¼ãƒˆã‚¯ãƒªã‚¢
                await tx.cartItem.deleteMany({
                    where: { cart_id: userCart.id }
                });

                return await this.buildOrderData(order.id, tx);

            } catch (error) {
                // ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ï¼šäºˆç´„ã‚’è§£é™¤
                await Promise.all(
                    userCart.cart_items.map(item =>
                        this.releaseReservation(item.food_id, item.quantity, tx)
                    )
                );
                throw error;
            }
        });
    }

    private static async confirmReservation(
        foodId: number,
        quantity: number,
        orderId: number,
        tx: any
    ): Promise<void> {
        const food = await tx.food.findUnique({ where: { id: foodId } });

        await tx.food.update({
            where: { id: foodId },
            data: {
                stock: food.stock - quantity,
                reserved: food.reserved - quantity
            }
        });

        // åœ¨åº«å±¥æ­´è¨˜éŒ²
        await tx.inventoryHistory.create({
            data: {
                food_id: foodId,
                change_type: 'subtract',
                quantity: quantity,
                previous_stock: food.stock,
                new_stock: food.stock - quantity,
                order_id: orderId,
                note: `æ³¨æ–‡ç¢ºå®šã«ã‚ˆã‚‹åœ¨åº«æ¸›ç®—`
            }
        });
    }
}
```

---

## 4. å­¦ç¿’çŸ¥è­˜ç‚¹

### 4.1 ä¸¦è¡Œåˆ¶å¾¡ã®åŸºç¤æ¦‚å¿µ

#### 4.1.1 ç«¶åˆçŠ¶æ…‹ï¼ˆRace Conditionï¼‰

**å®šç¾©:** è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒå…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã«åŒæ™‚ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹éš›ã€å®Ÿè¡Œé †åºã«ã‚ˆã£ã¦çµæœãŒå¤‰ã‚ã‚‹ç¾è±¡

**ä¾‹:**
```typescript
// å±é™ºãªã‚³ãƒ¼ãƒ‰ä¾‹
let counter = 0;

async function increment() {
    const current = counter;  // èª­ã¿å–ã‚Š
    counter = current + 1;    // æ›¸ãè¾¼ã¿
}

// åŒæ™‚å®Ÿè¡Œã™ã‚‹ã¨æœŸå¾…å€¤ã¨ç•°ãªã‚‹çµæœã«ãªã‚‹å¯èƒ½æ€§
await Promise.all([increment(), increment(), increment()]);
// æœŸå¾…å€¤: 3, å®Ÿéš›: 1 or 2 or 3ï¼ˆä¸å®šï¼‰
```

#### 4.1.2 åŸå­æ€§ï¼ˆAtomicityï¼‰

**å®šç¾©:** æ“ä½œãŒåˆ†å‰²ä¸å¯èƒ½ãªå˜ä½ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨

**ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¬ãƒ™ãƒ«:**
```sql
-- åŸå­çš„ãªæ›´æ–°
UPDATE foods
SET stock = stock - 5
WHERE id = 1 AND stock >= 5;
-- ã“ã®æ“ä½œã¯ä¸­æ–­ã•ã‚Œãªã„
```

#### 4.1.3 åˆ†é›¢ãƒ¬ãƒ™ãƒ«ï¼ˆIsolation Levelsï¼‰

| ãƒ¬ãƒ™ãƒ« | ç¾è±¡ | PostgreSQLè¨­å®š |
|--------|------|----------------|
| **Read Uncommitted** | ãƒ€ãƒ¼ãƒ†ã‚£ãƒªãƒ¼ãƒ‰å¯èƒ½ | `READ UNCOMMITTED` |
| **Read Committed** | ãƒãƒ³ãƒªãƒ”ãƒ¼ã‚¿ãƒ–ãƒ«ãƒªãƒ¼ãƒ‰å¯èƒ½ | `READ COMMITTED` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) |
| **Repeatable Read** | ãƒ•ã‚¡ãƒ³ãƒˆãƒ ãƒªãƒ¼ãƒ‰å¯èƒ½ | `REPEATABLE READ` |
| **Serializable** | å®Œå…¨åˆ†é›¢ | `SERIALIZABLE` |

### 4.2 ãƒ­ãƒƒã‚¯æ©Ÿèƒ½ã®ç¨®é¡

#### 4.2.1 æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ vs æ‚²è¦³çš„ãƒ­ãƒƒã‚¯

**æ¥½è¦³çš„ãƒ­ãƒƒã‚¯:**
```typescript
// ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã«ã‚ˆã‚‹æ¥½è¦³çš„ãƒ­ãƒƒã‚¯
interface Food {
    id: number;
    stock: number;
    version: number; // æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ç”¨
}

// æ›´æ–°æ™‚ã«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
const result = await prisma.food.updateMany({
    where: { id: foodId, version: currentVersion },
    data: { stock: newStock, version: currentVersion + 1 }
});

if (result.count === 0) {
    throw new Error('ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒåŒæ™‚ã«æ›´æ–°ã—ã¾ã—ãŸ');
}
```

**æ‚²è¦³çš„ãƒ­ãƒƒã‚¯:**
```sql
-- PostgreSQLã®è¡Œãƒ¬ãƒ™ãƒ«ãƒ­ãƒƒã‚¯
BEGIN;
SELECT * FROM foods WHERE id = 1 FOR UPDATE;
-- ã“ã®è¡Œã¯ä»–ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹
UPDATE foods SET stock = stock - 5 WHERE id = 1;
COMMIT;
```

#### 4.2.2 ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯å›é¿æˆ¦ç•¥

**ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ä¾‹:**
```
Transaction A: Lock(Food1) â†’ Wait(Food2)
Transaction B: Lock(Food2) â†’ Wait(Food1)
çµæœ: ç›¸äº’ã«å¾…æ©Ÿã—ã¦ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯
```

**å›é¿æ–¹æ³•:**
```typescript
// 1. å¸¸ã«åŒã˜é †åºã§ãƒ­ãƒƒã‚¯
const foodIds = [foodId1, foodId2].sort();
for (const id of foodIds) {
    await lockFood(id);
}

// 2. ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
await prisma.$transaction(async (tx) => {
    // å‡¦ç†...
}, {
    timeout: 5000, // 5ç§’ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
});
```

### 4.3 PostgreSQLå›ºæœ‰ã®æ©Ÿèƒ½

#### 4.3.1 MVCCï¼ˆMulti-Version Concurrency Controlï¼‰

**æ¦‚å¿µ:** PostgreSQLã¯è¡Œã®è¤‡æ•°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä¿æŒã—ã€ä¸¦è¡Œã‚¢ã‚¯ã‚»ã‚¹ã‚’åŠ¹ç‡åŒ–

```sql
-- ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³åˆ†é›¢ã®ä¾‹
-- Transaction A
BEGIN;
SELECT stock FROM foods WHERE id = 1; -- çµæœ: 10

-- Transaction B (åŒæ™‚å®Ÿè¡Œ)
BEGIN;
UPDATE foods SET stock = 5 WHERE id = 1;
COMMIT;

-- Transaction A (ç¶šã)
SELECT stock FROM foods WHERE id = 1; -- çµæœ: 10 (Read Committed)
COMMIT;
```

#### 4.3.2 è¡Œãƒ¬ãƒ™ãƒ«ãƒ­ãƒƒã‚¯ã®ç¨®é¡

```sql
-- å…±æœ‰ãƒ­ãƒƒã‚¯ï¼ˆèª­ã¿å–ã‚Šç”¨ï¼‰
SELECT * FROM foods WHERE id = 1 FOR SHARE;

-- æ’ä»–ãƒ­ãƒƒã‚¯ï¼ˆæ›´æ–°ç”¨ï¼‰
SELECT * FROM foods WHERE id = 1 FOR UPDATE;

-- ãƒ­ãƒƒã‚¯å¾…æ©Ÿãªã—
SELECT * FROM foods WHERE id = 1 FOR UPDATE NOWAIT;

-- ãƒ­ãƒƒã‚¯å¾…æ©Ÿã‚¹ã‚­ãƒƒãƒ—
SELECT * FROM foods WHERE id = 1 FOR UPDATE SKIP LOCKED;
```

### 4.4 Prismaã§ã®ä¸¦è¡Œåˆ¶å¾¡

#### 4.4.1 ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½¿ç”¨æ³•

```typescript
// åŸºæœ¬çš„ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³
await prisma.$transaction(async (tx) => {
    const user = await tx.user.create({ data: userData });
    const cart = await tx.cart.create({ data: { user_id: user.id } });
    return { user, cart };
});

// åˆ†é›¢ãƒ¬ãƒ™ãƒ«æŒ‡å®š
await prisma.$transaction(
    async (tx) => {
        // å‡¦ç†...
    },
    {
        isolationLevel: 'RepeatableRead',
        timeout: 10000,
    }
);
```

#### 4.4.2 ç”ŸSQLã¨Prismaã®çµ„ã¿åˆã‚ã›

```typescript
// è¤‡é›‘ãªãƒ­ãƒƒã‚¯å‡¦ç†ã§ã¯ç”ŸSQLã‚’ä½¿ç”¨
await prisma.$transaction(async (tx) => {
    // æ‚²è¦³çš„ãƒ­ãƒƒã‚¯ï¼ˆç”ŸSQLï¼‰
    const [food] = await tx.$queryRaw`
        SELECT * FROM foods
        WHERE id = ${foodId}
        FOR UPDATE
    `;

    // Prisma ORMï¼ˆå‹å®‰å…¨ï¼‰
    await tx.food.update({
        where: { id: foodId },
        data: { stock: food.stock - quantity }
    });
});
```

### 4.5 ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥

#### 4.5.1 ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ã‚¨ãƒ©ãƒ¼ã®åˆ¤å®š

```typescript
function isRetryableError(error: any): boolean {
    // PostgreSQLå›ºæœ‰ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
    const retryableCodes = [
        '40001', // serialization_failure
        '40P01', // deadlock_detected
        '23505', // unique_violationï¼ˆéƒ¨åˆ†çš„ï¼‰
    ];

    return retryableCodes.some(code =>
        error.code === code || error.message.includes(code)
    );
}

// ã‚¨ã‚¯ã‚¹ãƒãƒãƒ³ã‚·ãƒ£ãƒ«ãƒãƒƒã‚¯ã‚ªãƒ•
async function retryWithBackoff<T>(
    operation: () => Promise<T>,
    maxRetries: number = 3
): Promise<T> {
    let lastError: any;

    for (let i = 0; i < maxRetries; i++) {
        try {
            return await operation();
        } catch (error) {
            lastError = error;

            if (!isRetryableError(error) || i === maxRetries - 1) {
                throw error;
            }

            // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•: 100ms, 200ms, 400ms...
            const delay = 100 * Math.pow(2, i) + Math.random() * 50;
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }

    throw lastError;
}
```

### 4.6 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

#### 4.6.1 ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æˆ¦ç•¥

```sql
-- åœ¨åº«ç®¡ç†ã«å¿…è¦ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_foods_stock_status ON foods(status, stock)
WHERE status = true;

CREATE INDEX idx_cart_items_user_food ON cart_items(cart_id, food_id);

CREATE INDEX idx_inventory_history_food_date
ON inventory_history(food_id, created_at);

-- éƒ¨åˆ†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆæ¡ä»¶ä»˜ãï¼‰
CREATE INDEX idx_foods_low_stock ON foods(stock)
WHERE stock < min_stock AND status = true;
```

#### 4.6.2 æ¥ç¶šãƒ—ãƒ¼ãƒ«è¨­å®š

```typescript
// Prismaæ¥ç¶šãƒ—ãƒ¼ãƒ«è¨­å®š
const prisma = new PrismaClient({
    datasources: {
        db: {
            url: process.env.DATABASE_URL +
                '?connection_limit=20' +     // æ¥ç¶šæ•°åˆ¶é™
                '&pool_timeout=20' +         // ãƒ—ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
                '&socket_timeout=60'         // ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
        }
    }
});
```

---

## 5. å®Ÿè£…è¨ˆç”»

### 5.1 æ®µéšçš„å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

#### Phase 1: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åŸºç›¤æ•´å‚™
- [ ] Foodãƒ†ãƒ¼ãƒ–ãƒ«ã«åœ¨åº«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ 
- [ ] åœ¨åº«å±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
- [ ] åŸºæœ¬çš„ãªåˆ¶ç´„ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¿½åŠ 
- [ ] Prismaã‚¹ã‚­ãƒ¼ãƒæ›´æ–°ã¨ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

#### Phase 2: åŸºæœ¬çš„ãªåœ¨åº«ç®¡ç†
- [ ] InventoryServiceã‚¯ãƒ©ã‚¹ä½œæˆ
- [ ] åŸºæœ¬çš„ãªåœ¨åº«å¢—æ¸›æ©Ÿèƒ½
- [ ] åœ¨åº«å±¥æ­´è¨˜éŒ²æ©Ÿèƒ½
- [ ] å˜ä½“ãƒ†ã‚¹ãƒˆä½œæˆ

#### Phase 3: æ¥½è¦³çš„ãƒ­ãƒƒã‚¯å®Ÿè£…
- [ ] ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†æ©Ÿèƒ½
- [ ] æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ãŸåœ¨åº«æ›´æ–°
- [ ] ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–

#### Phase 4: ã‚«ãƒ¼ãƒˆã‚µãƒ¼ãƒ“ã‚¹æ”¹å–„
- [ ] åœ¨åº«ãƒã‚§ãƒƒã‚¯ä»˜ãã‚«ãƒ¼ãƒˆæ“ä½œ
- [ ] ã‚«ãƒ¼ãƒˆæ“ä½œã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³åŒ–
- [ ] ã‚«ãƒ¼ãƒˆé–¢é€£ãƒ†ã‚¹ãƒˆ

#### Phase 5: æ³¨æ–‡ãƒ—ãƒ­ã‚»ã‚¹æ”¹å–„
- [ ] åœ¨åº«äºˆç´„ã‚·ã‚¹ãƒ†ãƒ 
- [ ] æ³¨æ–‡ç¢ºå®šæ™‚ã®åœ¨åº«ç¢ºå®š
- [ ] æ³¨æ–‡ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ™‚ã®åœ¨åº«æˆ»ã—
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆ

#### Phase 6: ç›£è¦–ã¨ãƒ­ã‚°
- [ ] åœ¨åº«å¤‰æ›´ãƒ­ã‚°
- [ ] ç«¶åˆæ¤œå‡ºãƒ­ã‚°
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
- [ ] ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½

### 5.2 ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

#### 5.2.1 å˜ä½“ãƒ†ã‚¹ãƒˆ
```typescript
// åœ¨åº«ç®¡ç†ã®ãƒ†ã‚¹ãƒˆä¾‹
describe('InventoryService', () => {
    test('åœ¨åº«æ¸›ç®—ãŒæ­£å¸¸ã«å‹•ä½œã™ã‚‹', async () => {
        // Given
        await createTestFood({ stock: 10 });

        // When
        const result = await InventoryService.updateStock(foodId, 3, 'subtract');

        // Then
        expect(result.newStock).toBe(7);
    });

    test('åœ¨åº«ä¸è¶³æ™‚ã¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹', async () => {
        // Given
        await createTestFood({ stock: 2 });

        // When & Then
        await expect(
            InventoryService.updateStock(foodId, 5, 'subtract')
        ).rejects.toThrow('åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
    });
});
```

#### 5.2.2 ä¸¦è¡Œæ€§ãƒ†ã‚¹ãƒˆ
```typescript
test('åŒæ™‚åœ¨åº«æ›´æ–°ã§ã‚‚æ•´åˆæ€§ãŒä¿ãŸã‚Œã‚‹', async () => {
    // Given
    await createTestFood({ stock: 100 });

    // When: 10å€‹ã®ä¸¦è¡Œæ›´æ–°ï¼ˆå„1å€‹æ¸›ç®—ï¼‰
    const promises = Array.from({ length: 10 }, () =>
        InventoryService.updateStock(foodId, 1, 'subtract')
    );

    await Promise.all(promises);

    // Then
    const food = await prisma.food.findUnique({ where: { id: foodId } });
    expect(food.stock).toBe(90);
});
```

### 5.3 æ€§èƒ½ç›®æ¨™

| ãƒ¡ãƒˆãƒªãƒƒã‚¯ | ç›®æ¨™å€¤ | æ¸¬å®šæ–¹æ³• |
|------------|--------|----------|
| **åœ¨åº«æ›´æ–°ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“** | < 100ms | APIãƒ†ã‚¹ãƒˆ |
| **åŒæ™‚åœ¨åº«æ›´æ–°å‡¦ç†** | 100ä¸¦è¡Œ | è² è·ãƒ†ã‚¹ãƒˆ |
| **ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§** | 100% | ä¸¦è¡Œæ€§ãƒ†ã‚¹ãƒˆ |
| **ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ç™ºç”Ÿç‡** | < 0.1% | ãƒ­ã‚°ç›£è¦– |

---

**æ¬¡å›:** Phase 1ã®å®Ÿè£…ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åŸºç›¤æ•´å‚™ï¼‰ã‚’é–‹å§‹ã—ã¾ã™ã€‚
