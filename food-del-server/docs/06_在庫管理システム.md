# 06_åœ¨åº«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

## é«˜åº¦ãªåœ¨åº«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ã¨è¨­è¨ˆ

### ğŸ“¦ åœ¨åº«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦

ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã®æœ€ã‚‚é«˜åº¦ãªæ©Ÿèƒ½ã®ä¸€ã¤ãŒ**åœ¨åº«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ **ã§ã™ã€‚æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ï¼ˆOptimistic Lockingï¼‰ã‚’åŸºç›¤ã¨ã—ãŸä¸¦è¡Œåˆ¶å¾¡ã«ã‚ˆã‚Šã€é«˜ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ç’°å¢ƒã§ã®ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã‚’ä¿è¨¼ã—ãªãŒã‚‰ã€è¤‡é›‘ãªåœ¨åº«æ“ä½œã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ã€‚

---

### ğŸ”„ åœ¨åº«ç®¡ç†ã®åŸºæœ¬æ¦‚å¿µ

#### **åœ¨åº«çŠ¶æ…‹ã®å¤šæ¬¡å…ƒç®¡ç†**

```typescript
// Foods ãƒ†ãƒ¼ãƒ–ãƒ«ã®åœ¨åº«é–¢é€£ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
model Food {
  // åŸºæœ¬å•†å“æƒ…å ±
  id          Int      @id @default(autoincrement())
  name        String
  price       Float

  // åœ¨åº«ç®¡ç†ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  stock       Int      @default(0)  // ç‰©ç†åœ¨åº«æ•°
  reserved    Int      @default(0)  // äºˆç´„æ¸ˆã¿åœ¨åº«
  min_stock   Int      @default(0)  // æœ€å°åœ¨åº«é–¾å€¤
  version     Int      @default(1)  // æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ç”¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³
}
```

#### **åœ¨åº«çŠ¶æ…‹ã®è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯**

```typescript
// åˆ©ç”¨å¯èƒ½åœ¨åº«ã®è¨ˆç®—
const availableStock = food.stock - food.reserved;

// åœ¨åº«çŠ¶æ³ã®åˆ¤å®š
const stockStatus = {
  isAvailable: availableStock > 0,
  isLowStock: food.stock <= food.min_stock,
  isOutOfStock: food.stock === 0,
  availableQuantity: availableStock
};
```

---

### âš¡ æ¥½è¦³çš„ãƒ­ãƒƒã‚¯å®Ÿè£…

#### **ä¸¦è¡Œåˆ¶å¾¡ã®æ ¸å¿ƒãƒ¡ã‚«ãƒ‹ã‚ºãƒ **

```typescript
static async updateStock(
    foodId: number,
    quantity: number,
    operation: 'add' | 'subtract',
    options: UpdateStockOptions
): Promise<StockUpdateResult> {
    const { maxRetries = 3 } = options;
    let retries = 0;

    while (retries < maxRetries) {
        try {
            return await prisma.$transaction(async (tx) => {
                // 1. ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å•†å“å–å¾—
                const food = await tx.food.findUnique({
                    where: { id: foodId },
                    select: {
                        id: true, name: true, stock: true,
                        reserved: true, version: true, status: true
                    }
                });

                if (!food) {
                    throw new Error('å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }

                // 2. ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«æ¤œè¨¼
                const newStock = operation === 'add'
                    ? food.stock + quantity
                    : food.stock - quantity;

                if (newStock < 0) {
                    throw new Error(`åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚åˆ©ç”¨å¯èƒ½åœ¨åº«: ${food.stock}å€‹`);
                }

                if (newStock < food.reserved) {
                    throw new Error(`äºˆç´„æ¸ˆã¿åœ¨åº«ã‚’ä¸‹å›ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚äºˆç´„æ¸ˆã¿: ${food.reserved}å€‹`);
                }

                // 3. æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ - ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯ä»˜ãæ›´æ–°
                const updatedFood = await tx.food.updateMany({
                    where: {
                        id: foodId,
                        version: food.version  // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä¸€è‡´ãƒã‚§ãƒƒã‚¯
                    },
                    data: {
                        stock: newStock,
                        version: food.version + 1  // ãƒãƒ¼ã‚¸ãƒ§ãƒ³å¢—åŠ 
                    }
                });

                // 4. ç«¶åˆæ¤œçŸ¥
                if (updatedFood.count === 0) {
                    throw new Error('CONCURRENT_UPDATE');
                }

                // 5. å¤‰æ›´å±¥æ­´è¨˜éŒ²
                await this.recordInventoryChange(tx, {
                    foodId, changeType: operation, quantity,
                    previousStock: food.stock, newStock,
                    orderId: options.orderId,
                    createdBy: options.userId,
                    note: `åœ¨åº«${operation === 'add' ? 'è¿½åŠ ' : 'æ¸›ç®—'}: ${quantity}å€‹`
                });

                return {
                    success: true,
                    newStock,
                    version: food.version + 1
                };
            });

        } catch (error: any) {
            // 6. ç«¶åˆæ™‚ã®ãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥
            if (error.message === 'CONCURRENT_UPDATE' && retries < maxRetries - 1) {
                retries++;
                // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã«ã‚ˆã‚‹é…å»¶
                const delay = Math.random() * Math.pow(2, retries) * 50;
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
            }
            throw error;
        }
    }

    throw new Error('ä¸¦è¡Œæ›´æ–°ã®ç«¶åˆã«ã‚ˆã‚Šæ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ');
}
```

---

### ğŸ”’ åœ¨åº«äºˆç´„ã‚·ã‚¹ãƒ†ãƒ 

#### **ã‚«ãƒ¼ãƒˆé€£æºã«ã‚ˆã‚‹åœ¨åº«äºˆç´„**

```typescript
static async reserveStock(
    foodId: number,
    quantity: number,
    userId: number,
    note?: string
): Promise<{ success: boolean; availableStock: number }> {
    return await prisma.$transaction(async (tx) => {
        // æ‚²è¦³çš„ãƒ­ãƒƒã‚¯ã§å•†å“å–å¾—ï¼ˆäºˆç´„æ™‚ã¯ç¢ºå®Ÿã«ãƒ­ãƒƒã‚¯ï¼‰
        const [food] = await tx.$queryRaw<Array<{
            id: number; stock: number; reserved: number;
            status: boolean; name: string;
        }>>`
            SELECT id, stock, reserved, status, name
            FROM foods
            WHERE id = ${foodId}
            FOR UPDATE  -- æ‚²è¦³çš„ãƒ­ãƒƒã‚¯
        `;

        if (!food) {
            throw new Error('å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
        }

        if (!food.status) {
            throw new Error('å•†å“ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
        }

        // åˆ©ç”¨å¯èƒ½åœ¨åº«ã®è¨ˆç®—
        const availableStock = food.stock - food.reserved;

        if (availableStock < quantity) {
            throw new Error(
                `åœ¨åº«ä¸è¶³ã§ã™ã€‚åˆ©ç”¨å¯èƒ½åœ¨åº«: ${availableStock}å€‹ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: ${quantity}å€‹`
            );
        }

        // äºˆç´„åœ¨åº«ã‚’å¢—åŠ 
        await tx.food.update({
            where: { id: foodId },
            data: { reserved: food.reserved + quantity }
        });

        // å±¥æ­´è¨˜éŒ²
        await this.recordInventoryChange(tx, {
            foodId,
            changeType: this.CHANGE_TYPES.RESERVE,
            quantity,
            previousStock: food.stock,
            newStock: food.stock, // å®Ÿéš›ã®åœ¨åº«ã¯å¤‰ã‚ã‚‰ãªã„
            createdBy: userId,
            note: note || `åœ¨åº«äºˆç´„: ${quantity}å€‹`
        });

        return {
            success: true,
            availableStock: availableStock - quantity
        };
    });
}
```

#### **äºˆç´„è§£é™¤ãƒ¡ã‚«ãƒ‹ã‚ºãƒ **

```typescript
static async releaseReservation(
    foodId: number,
    quantity: number,
    userId: number,
    note?: string
): Promise<{ success: boolean; availableStock: number }> {
    return await prisma.$transaction(async (tx) => {
        const food = await tx.food.findUnique({
            where: { id: foodId },
            select: { stock: true, reserved: true, status: true }
        });

        if (!food) {
            throw new Error('å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
        }

        if (food.reserved < quantity) {
            throw new Error(`äºˆç´„è§£é™¤æ•°é‡ãŒäºˆç´„æ¸ˆã¿æ•°é‡ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚äºˆç´„æ¸ˆã¿: ${food.reserved}å€‹`);
        }

        // äºˆç´„åœ¨åº«ã‚’æ¸›å°‘
        await tx.food.update({
            where: { id: foodId },
            data: { reserved: food.reserved - quantity }
        });

        // å±¥æ­´è¨˜éŒ²
        await this.recordInventoryChange(tx, {
            foodId,
            changeType: this.CHANGE_TYPES.RELEASE,
            quantity,
            previousStock: food.stock,
            newStock: food.stock,
            createdBy: userId,
            note: note || `äºˆç´„è§£é™¤: ${quantity}å€‹`
        });

        return {
            success: true,
            availableStock: food.stock - (food.reserved - quantity)
        };
    });
}
```

---

### ğŸ“‹ åœ¨åº«ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†

#### **å®Œå…¨ãªåœ¨åº«ãƒ•ãƒ­ãƒ¼ã®å®Ÿè£…**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    äºˆç´„     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    ç¢ºå®š     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ã‚«ãƒ¼ãƒˆ    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   äºˆç´„çŠ¶æ…‹   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   ç¢ºå®šæ¸ˆã¿   â”‚
â”‚   è¿½åŠ       â”‚            â”‚   reserved   â”‚            â”‚   sold       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                          â”‚                          â”‚
       â”‚ å‰Šé™¤/æœŸé™åˆ‡ã‚Œ              â”‚ ã‚­ãƒ£ãƒ³ã‚»ãƒ«                 â”‚ è¿”å“
       â–¼                          â–¼                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   è§£é™¤      â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   è§£é™¤      â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   è¿”å“å‡¦ç†   â”‚
â”‚   released  â”‚            â”‚   released  â”‚            â”‚   returned  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **æ³¨æ–‡ç¢ºå®šæ™‚ã®åœ¨åº«ç¢ºå®š**

```typescript
static async confirmReservation(
    foodId: number,
    quantity: number,
    orderId: number,
    userId: number
): Promise<{ success: boolean; newStock: number }> {
    return await prisma.$transaction(async (tx) => {
        const food = await tx.food.findUnique({
            where: { id: foodId },
            select: { stock: true, reserved: true, version: true }
        });

        if (!food) {
            throw new Error('å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
        }

        if (food.reserved < quantity) {
            throw new Error(`ç¢ºå®šæ•°é‡ãŒäºˆç´„æ¸ˆã¿æ•°é‡ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚äºˆç´„æ¸ˆã¿: ${food.reserved}å€‹`);
        }

        const newStock = food.stock - quantity;
        const newReserved = food.reserved - quantity;

        // åœ¨åº«ã¨äºˆç´„ã‚’åŒæ™‚ã«æ¸›ç®—ï¼ˆæ¥½è¦³çš„ãƒ­ãƒƒã‚¯ä»˜ãï¼‰
        const updateResult = await tx.food.updateMany({
            where: {
                id: foodId,
                version: food.version  // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
            },
            data: {
                stock: newStock,
                reserved: newReserved,
                version: food.version + 1
            }
        });

        if (updateResult.count === 0) {
            throw new Error('åœ¨åº«æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆç«¶åˆç™ºç”Ÿï¼‰');
        }

        // å±¥æ­´è¨˜éŒ²
        await this.recordInventoryChange(tx, {
            foodId,
            changeType: this.CHANGE_TYPES.SUBTRACT,
            quantity,
            previousStock: food.stock,
            newStock,
            orderId,
            createdBy: userId,
            note: `æ³¨æ–‡ç¢ºå®šã«ã‚ˆã‚‹åœ¨åº«æ¸›ç®—ï¼ˆæ³¨æ–‡ID: ${orderId}ï¼‰`
        });

        return { success: true, newStock };
    });
}
```

---

### ğŸ“Š åœ¨åº«å±¥æ­´ãƒ»ç›£æŸ»ã‚·ã‚¹ãƒ†ãƒ 

#### **å®Œå…¨ãªå¤‰æ›´å±¥æ­´è¿½è·¡**

```typescript
// InventoryHistory ãƒ†ãƒ¼ãƒ–ãƒ«ã«ã‚ˆã‚‹å®Œå…¨ãªç›£æŸ»è¨¼è·¡
model InventoryHistory {
  id              Int      @id @default(autoincrement())
  food_id         Int      // å¯¾è±¡å•†å“ID
  change_type     String   // å¤‰æ›´ç¨®åˆ¥: add, subtract, reserve, release
  quantity        Int      // å¤‰æ›´æ•°é‡
  previous_stock  Int      // å¤‰æ›´å‰åœ¨åº«
  new_stock       Int      // å¤‰æ›´å¾Œåœ¨åº«
  order_id        Int?     // é–¢é€£æ³¨æ–‡IDï¼ˆä»»æ„ï¼‰
  created_by      Int      // å¤‰æ›´å®Ÿè¡Œè€…
  created_at      DateTime @default(now())
  note            String?  // å¤‰æ›´ç†ç”±ãƒ»å‚™è€ƒ

  // ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
  food            Food     @relation(fields: [food_id], references: [id])
  order           Order?   @relation(fields: [order_id], references: [id])
  created_by_user User     @relation(fields: [created_by], references: [id])

  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  @@index([food_id])
  @@index([created_at])
  @@index([change_type])
  @@map("inventory_history")
}
```

#### **å±¥æ­´è¨˜éŒ²ã®è‡ªå‹•åŒ–**

```typescript
private static async recordInventoryChange(
    tx: any,  // Prisma ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³
    data: {
        foodId: number;
        changeType: string;
        quantity: number;
        previousStock: number;
        newStock: number;
        orderId?: number;
        createdBy: number;
        note?: string;
    }
): Promise<void> {
    await tx.inventoryHistory.create({
        data: {
            food_id: data.foodId,
            change_type: data.changeType,
            quantity: data.quantity,
            previous_stock: data.previousStock,
            new_stock: data.newStock,
            order_id: data.orderId,
            created_by: data.createdBy,
            note: data.note
        }
    });
}
```

---

### ğŸš¨ åœ¨åº«ã‚¢ãƒ©ãƒ¼ãƒˆãƒ»ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 

#### **åœ¨åº«çŠ¶æ³ã®åŒ…æ‹¬çš„ç›£è¦–**

```typescript
static async getStockInfo(foodId: number): Promise<{
    stock: number;
    reserved: number;
    available: number;
    minStock: number;
    isLowStock: boolean;
} | null> {
    const food = await prisma.food.findUnique({
        where: { id: foodId },
        select: {
            stock: true,
            reserved: true,
            min_stock: true
        }
    });

    if (!food) return null;

    const available = food.stock - food.reserved;
    const isLowStock = food.stock <= food.min_stock;

    return {
        stock: food.stock,
        reserved: food.reserved,
        available,
        minStock: food.min_stock,
        isLowStock
    };
}
```

#### **å…¨å•†å“åœ¨åº«çŠ¶æ³ã®ä¸€æ‹¬å–å¾—**

```typescript
static async getAllStockStatus(
    options: {
        lowStockOnly?: boolean;
        limit?: number;
        offset?: number;
    } = {}
): Promise<StockStatusResult[]> {
    const { lowStockOnly = false, limit = 100, offset = 0 } = options;

    const foods = await prisma.food.findMany({
        select: {
            id: true, name: true, stock: true,
            reserved: true, min_stock: true, status: true
        },
        take: limit,
        skip: offset,
        orderBy: { name: 'asc' }
    });

    const stockStatus = foods.map(food => {
        const available = food.stock - food.reserved;
        const isLowStock = food.stock <= food.min_stock;

        return {
            id: food.id,
            name: food.name,
            stock: food.stock,
            reserved: food.reserved,
            available,
            minStock: food.min_stock,
            isLowStock,
            status: food.status
        };
    });

    // ä½åœ¨åº«ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    return lowStockOnly
        ? stockStatus.filter(item => item.isLowStock)
        : stockStatus;
}
```

---

### âš ï¸ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ»ä¾‹å¤–å‡¦ç†

#### **åœ¨åº«å°‚ç”¨ã‚¨ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹**

```typescript
export class StockError extends Error {
    constructor(
        public readonly foodName: string,
        public readonly requested: number,
        public readonly available: number,
        public readonly type: 'insufficient' | 'reserved' | 'unavailable' | 'conflict'
    ) {
        super();
        this.name = 'StockError';
        this.message = this.formatMessage();
    }

    private formatMessage(): string {
        switch (this.type) {
            case 'insufficient':
                return `${this.foodName}ã®åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚åˆ©ç”¨å¯èƒ½: ${this.available}å€‹ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: ${this.requested}å€‹`;
            case 'reserved':
                return `${this.foodName}ã¯ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚Šäºˆç´„æ¸ˆã¿ã§ã™`;
            case 'unavailable':
                return `${this.foodName}ã¯ç¾åœ¨åˆ©ç”¨ã§ãã¾ã›ã‚“`;
            case 'conflict':
                return `${this.foodName}ã®åœ¨åº«ã«åŒæ™‚ã‚¢ã‚¯ã‚»ã‚¹ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾Œã«å†è©¦è¡Œã—ã¦ãã ã•ã„`;
            default:
                return `${this.foodName}ã®åœ¨åº«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ`;
        }
    }
}
```

#### **ã‚¨ãƒ©ãƒ¼æƒ…å ±ã®æ§‹é€ åŒ–**

```typescript
export class StockErrorInfoBuilder {
    static build(error: StockError): StockErrorInfo {
        const severity = StockErrorHelper.getErrorSeverity(error);
        const httpStatus = StockErrorHelper.getHttpStatusCode(error);
        const userMessage = StockErrorHelper.getUserFriendlyMessage(error);
        const suggestions = this.generateSuggestions(error);

        return {
            error, severity, httpStatus, userMessage,
            systemMessage: error.message, suggestions
        };
    }

    private static generateSuggestions(error: StockError): string[] {
        const suggestions: string[] = [];

        switch (error.type) {
            case 'insufficient':
                if (error.available > 0) {
                    suggestions.push(`æ•°é‡ã‚’${error.available}å€‹ä»¥ä¸‹ã«å¤‰æ›´ã—ã¦ãã ã•ã„`);
                }
                suggestions.push('é¡ä¼¼å•†å“ã‚’ãŠæ¢ã—ãã ã•ã„');
                suggestions.push('å†å…¥è·ã®ãŠçŸ¥ã‚‰ã›ã«ã”ç™»éŒ²ãã ã•ã„');
                break;
            case 'conflict':
                suggestions.push('ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„');
                suggestions.push('æ•°åˆ†å¾Œã«å†åº¦ãŠè©¦ã—ãã ã•ã„');
                break;
        }

        return suggestions;
    }
}
```

---

### ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

#### **ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æˆ¦ç•¥**

```sql
-- åœ¨åº«ç®¡ç†ç”¨ã®æœ€é©åŒ–ã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX "inventory_history_food_id_idx" ON "inventory_history"("food_id");
CREATE INDEX "inventory_history_created_at_idx" ON "inventory_history"("created_at");
CREATE INDEX "inventory_history_change_type_idx" ON "inventory_history"("change_type");

-- è¤‡åˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚ˆã‚‹ã‚¯ã‚¨ãƒªæœ€é©åŒ–
CREATE INDEX "foods_stock_status_idx" ON "foods"("stock", "status");
CREATE INDEX "foods_reserved_status_idx" ON "foods"("reserved", "status");
```

#### **ã‚¯ã‚¨ãƒªæœ€é©åŒ–ä¾‹**

```typescript
// åŠ¹ç‡çš„ãªä½åœ¨åº«å•†å“æ¤œç´¢
const lowStockFoods = await prisma.food.findMany({
  where: {
    status: true,
    stock: { lte: prisma.food.fields.min_stock }  // stock <= min_stock
  },
  select: {
    id: true, name: true, stock: true,
    min_stock: true, reserved: true
  },
  orderBy: [
    { stock: 'asc' },        // åœ¨åº«æ•°æ˜‡é †
    { min_stock: 'desc' }    // é‡è¦åº¦é™é †
  ]
});
```

---

### ğŸ”„ å®Ÿé‹ç”¨ã§ã®è€ƒæ…®äº‹é …

#### **ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯**

```typescript
// å®šæœŸçš„ãªæ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
static async validateInventoryConsistency(): Promise<{
  valid: boolean;
  errors: string[];
}> {
  const errors: string[] = [];

  // 1. è² ã®åœ¨åº«ãƒã‚§ãƒƒã‚¯
  const negativeStock = await prisma.food.findMany({
    where: { stock: { lt: 0 } },
    select: { id: true, name: true, stock: true }
  });

  if (negativeStock.length > 0) {
    errors.push(`è² ã®åœ¨åº«ã‚’æŒã¤å•†å“: ${negativeStock.length}ä»¶`);
  }

  // 2. äºˆç´„åœ¨åº«ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
  const invalidReservation = await prisma.food.findMany({
    where: { reserved: { gt: prisma.food.fields.stock } },
    select: { id: true, name: true, stock: true, reserved: true }
  });

  if (invalidReservation.length > 0) {
    errors.push(`äºˆç´„åœ¨åº«ãŒå®Ÿåœ¨åº«ã‚’è¶…é: ${invalidReservation.length}ä»¶`);
  }

  return {
    valid: errors.length === 0,
    errors
  };
}
```

#### **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹**

```typescript
// åœ¨åº«æ“ä½œã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬
static async measureStockOperationPerformance(): Promise<PerformanceMetrics> {
  const startTime = Date.now();

  const metrics = {
    averageUpdateTime: 0,
    concurrentUpdateSuccess: 0,
    conflictResolutionTime: 0,
    throughputPerSecond: 0
  };

  // ä¸¦è¡Œæ›´æ–°ãƒ†ã‚¹ãƒˆ
  const concurrentUpdates = Array.from({ length: 10 }, (_, i) =>
    this.updateStock(1, 1, 'add', { userId: 1 })
  );

  try {
    await Promise.all(concurrentUpdates);
    metrics.concurrentUpdateSuccess = 1;
  } catch (error) {
    metrics.concurrentUpdateSuccess = 0;
  }

  const endTime = Date.now();
  metrics.averageUpdateTime = (endTime - startTime) / 10;

  return metrics;
}
```

---

### ğŸ¯ åœ¨åº«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®è©•ä¾¡

#### **ã‚·ã‚¹ãƒ†ãƒ æˆç†Ÿåº¦ãƒ¡ãƒˆãƒªã‚¯ã‚¹**

| é …ç›® | è©•ä¾¡ | èª¬æ˜ |
|------|------|------|
| **ä¸¦è¡Œåˆ¶å¾¡** | â­â­â­â­â­ | æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ + ãƒªãƒˆãƒ©ã‚¤æ©Ÿæ§‹ |
| **ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§** | â­â­â­â­â­ | å®Œå…¨ãªåˆ¶ç´„ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ |
| **å±¥æ­´ç®¡ç†** | â­â­â­â­â­ | åŒ…æ‹¬çš„ãªç›£æŸ»è¨¼è·¡ |
| **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹** | â­â­â­â­â˜† | æœ€é©åŒ–ã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æˆ¦ç•¥ |
| **ã‚¨ãƒ©ãƒ¼å‡¦ç†** | â­â­â­â­â­ | æ§‹é€ åŒ–ã•ã‚ŒãŸä¾‹å¤–å‡¦ç† |
| **ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆ** | â­â­â­â­â˜† | ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çŠ¶æ³ç›£è¦– |

#### **å®Ÿè£…ã®æŠ€è¡“çš„ä¾¡å€¤**

1. **ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºãƒ¬ãƒ™ãƒ«**: å®Ÿéš›ã®ECã‚µã‚¤ãƒˆã§ä½¿ç”¨å¯èƒ½
2. **é«˜å¯ç”¨æ€§**: ä¸¦è¡Œã‚¢ã‚¯ã‚»ã‚¹ã«å¯¾ã™ã‚‹å …ç‰¢æ€§
3. **å®Œå…¨æ€§**: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®å³æ ¼ãªä¿è¨¼
4. **é€æ˜æ€§**: ã™ã¹ã¦ã®å¤‰æ›´ã®å®Œå…¨ãªè¿½è·¡
5. **æ‹¡å¼µæ€§**: å°†æ¥ã®æ©Ÿèƒ½æ‹¡å¼µã«å¯¾å¿œ

---

### ğŸ”® å°†æ¥çš„ãªæ‹¡å¼µå¯èƒ½æ€§

#### **çŸ­æœŸçš„æ”¹å–„è¨ˆç”»**

```typescript
const nearTermEnhancements = {
  'ã‚­ãƒ£ãƒƒã‚·ãƒ¥çµ±åˆ': 'Redis ã«ã‚ˆã‚‹åœ¨åº«çŠ¶æ³ã‚­ãƒ£ãƒƒã‚·ãƒ¥',
  'è‡ªå‹•è£œå……': 'æœ€å°åœ¨åº«ã‚’ä¸‹å›ã£ãŸéš›ã®è‡ªå‹•ç™ºæ³¨',
  'ãƒãƒƒãƒå‡¦ç†': 'å¤§é‡åœ¨åº«æ›´æ–°ã®åŠ¹ç‡åŒ–',
  'ã‚¢ãƒ©ãƒ¼ãƒˆå¼·åŒ–': 'Slack/email é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ '
};
```

#### **é•·æœŸçš„ç™ºå±•æ§‹æƒ³**

```typescript
const longTermVision = {
  'äºˆæ¸¬åˆ†æ': 'AI ã«ã‚ˆã‚‹éœ€è¦äºˆæ¸¬ã¨åœ¨åº«æœ€é©åŒ–',
  'ãƒãƒ«ãƒãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³': 'è¤‡æ•°å€‰åº«ãƒ»åº—èˆ—ã®çµ±åˆåœ¨åº«ç®¡ç†',
  'ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ': 'WebSocket ã«ã‚ˆã‚‹åœ¨åº«çŠ¶æ³ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é…ä¿¡',
  'ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³': 'åœ¨åº«å¤‰æ›´ã®ä¸æ”¹ã–ã‚“è¨¼æ˜'
};
```

---

### ğŸ’¡ ã¾ã¨ã‚

ã“ã®åœ¨åº«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¯ã€å­¦ç¿’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ ã‚’è¶…ãˆãŸæœ¬æ ¼çš„ãªå®Ÿè£…ã§ã™ï¼š

- **æ¥½è¦³çš„ãƒ­ãƒƒã‚¯**: é«˜ä¸¦è¡Œæ€§ã¨æ•´åˆæ€§ã®ä¸¡ç«‹
- **å®Œå…¨ãªç›£æŸ»è¨¼è·¡**: Enterpriseç´šã®å¤‰æ›´è¿½è·¡
- **å¤šæ®µéšäºˆç´„ã‚·ã‚¹ãƒ†ãƒ **: è¤‡é›‘ãªãƒ“ã‚¸ãƒã‚¹ãƒ•ãƒ­ãƒ¼ã¸ã®å¯¾å¿œ
- **å …ç‰¢ãªã‚¨ãƒ©ãƒ¼å‡¦ç†**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’é‡è¦–ã—ãŸä¾‹å¤–å‡¦ç†
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**: å®Ÿé‹ç”¨ã‚’è€ƒæ…®ã—ãŸè¨­è¨ˆ

ç‰¹ã«æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ã«ã‚ˆã‚‹ä¸¦è¡Œåˆ¶å¾¡ã®å®Ÿè£…ã¯ã€ç¾ä»£ã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§å¿…é ˆã®æŠ€è¡“ã§ã‚ã‚Šã€ã“ã®ãƒ¬ãƒ™ãƒ«ã®å®Ÿè£…çµŒé¨“ã¯å®Ÿå‹™ã«ãŠã„ã¦éå¸¸ã«è²´é‡ã§ã™ã€‚ã¾ãŸã€åœ¨åº«ã®äºˆç´„ãƒ»ç¢ºå®šãƒ»è§£é™¤ã¨ã„ã£ãŸè¤‡é›‘ãªãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†ã‚‚ã€å®Ÿéš›ã®ECã‚µã‚¤ãƒˆæ§‹ç¯‰ã§ç›´é¢ã™ã‚‹èª²é¡Œã‚’é©åˆ‡ã«è§£æ±ºã—ã¦ãŠã‚Šã€æ¥µã‚ã¦å®Ÿè·µçš„ãªå­¦ç¿’ä¾¡å€¤ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚