# 06. コアモジュール: 注文とトランザクション処理

## 1. 概要

注文処理は、このアプリケーションで最も重要かつ複雑なビジネスフローです。カートの商品を実際の注文に変換し、在庫を更新し、支払い情報を記録するまでの一連の操作は、データの不整合が絶対に許されません。

この整合性を保証するため、`OrderService` は Prisma の **データベーストランザクション (`$transaction`)** を全面的に活用しています。トランザクションは、一連のデータベース操作を「すべて成功するか、すべて失敗するか（All or Nothing）」の単一の作業単位として扱う仕組みです。

## 2. 注文作成フロー (`createOrderFromCart`)

このメソッドは、ユーザーの現在のカート内容から新しい注文を作成します。

### a. トランザクションの開始

すべてのロジックは `prisma.$transaction` のコールバック関数内にラップされています。これにより、途中で任何かのエラーが発生した場合、それまでに行われたデータベースへの変更（例：注文レコードの作成）はすべて自動的に**ロールバック**（取り消し）されます。

**コード例 (`src/services/orderService.ts`より):**
```typescript
static async createOrderFromCart(userId, orderRequest) {
    try {
        // トランザクションを開始
        return await prisma.$transaction(async (tx) => {
            // ↓↓↓ すべてのDB操作は `tx` クライアントを使用する ↓↓↓

            // ... (次のステップで解説する処理)

        });
    } catch (error) {
        // トランザクションがロールバックされた後、エラーを上位にスローする
        throw new Error(`注文作成に失敗しました: ${error?.message}`);
    }
}
```

### b. 処理ステップの解説

トランザクション内部では、以下の処理が順番に実行されます。

**コード例 (`src/services/orderService.ts`のトランザクション内部):**
```typescript
// 1. ユーザーのカート情報を取得
const userCart = await CartService.getFullCartWithItems(userId);
if (!userCart.cart_items.length) {
    throw new Error('カートが空です'); // エラーをスローするとトランザクションが中断・ロールバックされる
}

// 2. 在庫の事前検証
// (ここでは簡略化。実際には各商品の在庫をチェックするループがある)

// 3. 注文総額を計算
const totalAmount = userCart.cart_items.reduce((sum, item) => {
    return sum + (item.food.price * item.quantity);
}, 0);

// 4. `Order`テーブルに注文の基本情報を作成
const order = await tx.order.create({
    data: {
        user_id: userId,
        total_amount: totalAmount,
        delivery_address: orderRequest.delivery_address,
        // ...その他配送情報
    }
});

// 5. カート内の各商品を`OrderItem`に変換し、在庫を確定
await Promise.all(
    userCart.cart_items.map(async (item) => {
        // 5a. 在庫予約を確定（物理在庫と予約在庫を減算）
        await InventoryService.confirmReservation(
            item.food_id, item.quantity, order.id, userId, tx
        );

        // 5b. `OrderItem`を作成し、「価格スナップショット」を保存
        return await tx.orderItem.create({
            data: {
                order_id: order.id,
                food_id: item.food_id,
                quantity: item.quantity,
                price: item.food.price // 【重要】注文時点の価格を記録
            }
        });
    })
);

// 6. ユーザーのカートを空にする
await tx.cartItem.deleteMany({
    where: { cart_id: userCart.id }
});

// 7. 成功した場合、完全な注文データを返す
return await this.buildOrderData(order.id, tx);
```

## 3. 注文キャンセル処理 (`cancelOrder`) - 補償トランザクション

注文のキャンセルは、単にステータスを更新するだけではありません。以前の操作（在庫の減算）を取り消すための**補償トランザクション（Compensating Transaction）** を実行する必要があります。

**コード例 (`src/services/orderService.ts`より):**
```typescript
static async cancelOrder(orderId, userId, cancelData) {
    return await prisma.$transaction(async (tx) => {
        // 1. 注文の存在と所有権、キャンセル可能かを検証
        const order = await tx.order.findUnique({ ... });
        if (!order || !this.canCancelOrder(order.status)) {
            throw new Error('この注文はキャンセルできません');
        }

        // 2. 【重要】在庫の復元（補償ロジック）
        // 注文された各商品についてループ処理
        for (const item of order.order_items) {
            // `InventoryService`を呼び出し、在庫を`'add'`（追加）で元に戻す
            await InventoryService.updateStock(
                item.food_id,
                item.quantity,
                'add',
                { userId, note: `注文キャンセルによる在庫復元` }
            );
        }

        // 3. 監査ログにキャンセル履歴を記録
        await tx.orderStatusHistory.create({ ... });

        // 4. 注文ステータスを`CANCELLED`に更新
        await tx.order.update({
            where: { id: orderId },
            data: { status: OrderStatus.CANCELLED, ... }
        });

        return this.getOrderById(orderId, userId);
    });
}
```

## 4. 結論

`OrderService` は、データベーストランザクションを効果的に使用して、注文作成のような前方フローと、注文キャ​​ンセルのような後方（補償）フローの両方で、データの完全性と一貫性を保証しています。これは、信頼性の高いシステムを構築するための不可欠なパターンです。
