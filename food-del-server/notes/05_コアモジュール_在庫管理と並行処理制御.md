# 05. コアモジュール: 在庫管理と並行処理制御

## 1. 概要

在庫管理は、フードデリバリーやEコマースシステムの心臓部です。特に、複数のユーザーが同時に同じ商品にアクセスする高並行環境では、データの整合性を保つことが極めて重要になります。在庫が不正確になると、「在庫がないのに注文できてしまう（オーバーセリング）」といった致命的な問題を引き起こします。

このプロジェクトの `InventoryService` は、この課題を解決するために**楽観的ロック**と**悲観的ロック**という2つの高度な並行処理制御戦略を使い分けており、非常に優れた設計となっています。

## 2. 在庫の概念

まず、`Food`モデルにおける在庫関連の3つの重要なフィールドを理解する必要があります。

-   `stock`: 物理的な総在庫数。棚に実際に存在する商品の数。
-   `reserved`: 予約在庫数。ユーザーがカートに入れているが、まだ購入を完了していない商品の数。
-   **引当可能在庫**: `stock - reserved` で計算される、ユーザーが実際に購入できる在庫数。

## 3. 楽観的ロック (Optimistic Locking)

楽観的ロックは、「データの競合は滅多に発生しないだろう」という楽観的な想定のもと、更新時に初めて競合をチェックする手法です。性能への影響が少ないのが特徴です。

### a. ユースケース

管理者による在庫数の手動調整（例：商品の新規入荷）など、競合の可能性が低い操作で使用されます。

### b. 実装の解説 (`updateStock` メソッド)

このメソッドは、在庫の追加（`add`）または減算（`subtract`）を安全に行います。

**コード例 (`src/services/inventoryService.ts`より):**
```typescript
static async updateStock(foodId, quantity, operation, options) {
    let retries = 0;
    while (retries < maxRetries) { // 1. 競合発生時にリトライするためのループ
        try {
            return await prisma.$transaction(async (tx) => {
                // 2. 現在の商品情報を取得（versionを含む）
                const food = await tx.food.findUnique({
                    where: { id: foodId },
                    select: { stock: true, version: true, ... }
                });

                // ... (在庫計算)

                // 3. 【重要】versionを条件に加えて更新
                const updatedFood = await tx.food.updateMany({
                    where: {
                        id: foodId,
                        version: food.version // 読み取ったバージョンと一致する場合のみ
                    },
                    data: {
                        stock: newStock,
                        version: food.version + 1 // バージョンを+1する
                    }
                });

                // 4. 競合の検出
                if (updatedFood.count === 0) {
                    // 更新件数が0なら、他の誰かが先に更新したということ
                    throw new Error('CONCURRENT_UPDATE');
                }

                // ... (在庫履歴を記録)
                return { success: true, ... };
            });
        } catch (error) {
            // 5. 競合エラーを捕捉し、少し待ってからリトライ
            if (error.message === 'CONCURRENT_UPDATE' && retries < maxRetries - 1) {
                retries++;
                const delay = Math.random() * Math.pow(2, retries) * 50;
                await new Promise(resolve => setTimeout(resolve, delay));
                continue; // ループの先頭に戻る
            }
            throw error;
        }
    }
    throw new Error('並行更新の競合により操作に失敗しました');
}
```

この実装により、もし2つのリクエストが同時に在庫を更新しようとしても、先に成功した方が`version`を更新するため、後から来たリクエストは更新に失敗し、リトライ処理に入ります。これにより、在庫数が不正確になることを防ぎます。

## 4. 悲観的ロック (Pessimistic Locking)

悲観的ロックは、「データの競合は頻繁に発生するだろう」という悲観的な想定のもと、データにアクセスする最初の段階でそれをロックしてしまう手法です。データの整合性を最も確実に保証できますが、性能への影響が大きくなる可能性があります。

### a. ユースケース

ユーザーが商品をカートに追加する際の在庫予約（`reserveStock`）など、競合が頻発しうる操作で使用されます。

### b. 実装の解説 (`reserveStock` メソッド)

このメソッドは、データベースの行レベルロック機能（`FOR UPDATE`）を利用して実装されています。

**コード例 (`src/services/inventoryService.ts`より):**
```typescript
static async reserveStock(foodId, quantity, userId, note) {
    return await prisma.$transaction(async (tx) => {
        // 1. 【重要】`FOR UPDATE`句を使って行をロック
        // このクエリが完了するまで、他のトランザクションは
        // この行に対して待機させられる。
        const [food] = await tx.$queryRaw<...>`
            SELECT id, stock, reserved, status, name
            FROM foods
            WHERE id = ${foodId}
            FOR UPDATE
        `;

        if (!food) { throw new Error('商品が見つかりません'); }

        // 2. ロックを取得した後、安全に在庫をチェック
        const availableStock = food.stock - food.reserved;
        if (availableStock < quantity) {
            throw new Error(`在庫不足です。`);
        }

        // 3. 予約在庫を安全に更新
        await tx.food.update({
            where: { id: foodId },
            data: { reserved: food.reserved + quantity }
        });

        // ... (在庫履歴を記録)
        return { success: true, ... };
    });
}
```

`FOR UPDATE`によって、在庫チェックから予約数更新までの一連の処理が完了するまで、他の誰も同じ商品の在庫に触れることができなくなります。これにより、秒単位で多数のアクセスが集中する「秒殺」のようなシナリオでも、オーバーセリングを確実に防ぐことができます。

## 5. 結論

このプロジェクトは、操作の特性に応じて楽観的ロックと悲観的ロックを戦略的に使い分けています。これは、アプリケーションの性能とデータ整合性の両方を高いレベルで満たすための、非常に洗練されたアプローチです。
