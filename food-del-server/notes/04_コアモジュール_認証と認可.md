# 04. コアモジュール: 認証と認可

## 1. 概要

認証（Authentication）と認可（Authorization）は、本アプリケーションのセキュリティの根幹をなす機能です。

-   **認証**: 「ユーザーが誰であるか」を確認するプロセスです（ログインなど）。
-   **認可**: 「認証されたユーザーが何をする権限を持っているか」を決定するプロセスです（管理者か一般ユーザーかなど）。

この機能は主に `authService.ts`, `userController.ts`, `authMiddleware.ts` の3つのファイルによって実現されています。

## 2. 認証フロー

### a. ユーザー登録 (`POST /api/users/auth/register`)

ユーザーが新しいアカウントを作成する際のフローです。

**処理の流れ**:
1.  `userController` の `registerUser` 関数がリクエストを受け取ります。
2.  入力値（名前、メール、パスワード）の基本検証を行います。
3.  メールアドレスが既に存在しないかデータベースで確認します。
4.  `authService.validatePassword` を呼び出し、パスワードの強度を検証します。
5.  `authService.hashPassword` を呼び出し、パスワードを安全にハッシュ化します。
6.  ハッシュ化されたパスワードを含むユーザー情報をデータベースに保存します。
7.  `authService.createToken` を呼び出し、新規ユーザーのためのJWTを生成します。
8.  生成されたJWTとユーザー情報をクライアントに返します。

**コード例 (`src/controllers/userController.ts`より):**
```typescript
const registerUser = async (req, res) => {
    try {
        const { name, password, email } = req.body;

        // ... (入力値とユーザー存在チェック)

        // パスワード強度をチェック
        const passwordValidation = AuthService.validatePassword(password);
        if (!passwordValidation.isValid) {
            return res.status(400).json({ ... });
        }

        // ユーザーパスワードをハッシュ化
        const hashedPassword = await AuthService.hashPassword(password);

        // Prismaを使用して新しいユーザーを作成
        const user = await prisma.user.create({
            data: {
                name,
                email,
                password: hashedPassword,
                role: 'customer'
            }
        });

        // トークンを作成
        const token = AuthService.createToken({
            id: user.id,
            email: user.email,
            role: user.role
        });

        res.status(200).json({ success: true, data: { token, user: ... } });
    } catch (error) {
        // ... (エラーハンドリング)
    }
};
```

### b. パスワードの取り扱い

パスワードは決して平文で保存されません。`bcryptjs` ライブラリを使用して、不可逆的なハッシュ化が行われます。

**コード例 (`src/services/authService.ts`より):**
```typescript
// パスワードをハッシュ化
static async hashPassword(password: string): Promise<string> {
    // 10はソルトラウンド数。計算コストを決定する。
    return bcrypt.hash(password, 10);
}

// パスワードを比較
static async comparePassword(password: string, hash: string): Promise<boolean> {
    // 平文パスワードとハッシュ値を安全に比較
    return bcrypt.compare(password, hash);
}
```

## 3. JWT (JSON Web Token) の実装

認証されたユーザーにはJWTが発行され、以降のAPIリクエストで本人確認のために使用されます。

### a. トークンの生成

`authService` がアクセストークンとリフレッシュトークンの生成を担当します。セキュリティ向上のため、それぞれ異なる秘密鍵（`JWT_SECRET`, `JWT_REFRESH_SECRET`）を使用します。

**コード例 (`src/services/authService.ts`より):**
```typescript
// JWTアクセストークンを作成
static createToken(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {
    return jwt.sign(
        payload, // { id, email, role } を含むペイロード
        env.JWT_SECRET, // アクセストークン用の秘密鍵
        {
            expiresIn: '7d', // 有効期限: 7日間
            issuer: 'food-del-api', // 発行者
            audience: 'food-del-client' // 対象者
        }
    );
}

// リフレッシュトークンを作成
static createRefreshToken(userId: number): string {
    return jwt.sign(
        { userId, type: 'refresh' },
        env.JWT_REFRESH_SECRET, // リフレッシュトークン用の秘密鍵
        { expiresIn: '30d' } // 有効期限: 30日間
    );
}
```

### b. トークンの検証 (`isAuthenticated` ミドルウェア)

保護されたAPIエンドポイントにアクセスする際、`isAuthenticated` ミドルウェアがリクエストヘッダーのJWTを検証します。

**コード例 (`src/middleware/authMiddleware.ts`より):**
```typescript
export const isAuthenticated = async (req, res, next) => {
    try {
        // 1. Authorizationヘッダーから 'Bearer <token>' を取得
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return res.status(401).json({ message: "アクセストークンが必要です" });
        }

        const token = authHeader.split(' ')[1];

        // 2. JWTの署名と有効期限を検証
        const decoded = jwt.verify(token, env.JWT_SECRET);

        // 3. ペイロードの型をチェック
        if (!isJwtPayload(decoded)) {
            return res.status(401).json({ message: "無効なトークンペイロードです" });
        }

        // 4. 【重要】データベースでユーザーの存在を再確認
        // トークンが有効でも、ユーザーが削除されている可能性があるため
        const user = await prisma.user.findUnique({
            where: { id: decoded.id },
            select: { /* パスワード以外の全フィールド */ }
        });

        if (!user) {
            return res.status(404).json({ message: "ユーザーが見つかりません" });
        }

        // 5. 後続の処理で使えるように、リクエストオブジェクトにユーザー情報を格納
        req.user = user;
        next(); // 次のミドルウェアまたはコントローラーへ

    } catch (error) {
        // JWTの有効期限切れや署名エラーなどを処理
        // ...
    }
};
```

## 4. 認可（権限チェック）の実装

認可は、認証されたユーザーが特定のリソースにアクセスする権限を持っているかを確認するプロセスです。これは `isAdmin` ミドルウェアによって実現されます。

**コード例 (`src/middleware/authMiddleware.ts`より):**
```typescript
export const isAdmin = async (req, res, next) => {
    try {
        // ... (isAuthenticated と同じ認証プロセス) ...

        const user = await prisma.user.findUnique({ where: { id: decoded.id } });

        if (!user) {
            return res.status(404).json({ message: "ユーザーが見つかりません" });
        }

        // 6. ユーザーの役割（role）をチェック
        if (user.role !== 'admin') {
            // 管理者でない場合は 403 Forbidden エラーを返す
            return res.status(403).json({ message: "管理者権限が必要です" });
        }

        // 7. 認証・認可成功。リクエストにユーザー情報を格納して次へ
        req.user = user;
        next();

    } catch (error) {
        // ... (エラーハンドリング)
    }
};
```
このミドルウェアは、認証プロセスに加えて、ユーザーの `role` が `'admin'` であることを強制します。これにより、管理者専用のAPIエンドポイントを安全に保護できます。
