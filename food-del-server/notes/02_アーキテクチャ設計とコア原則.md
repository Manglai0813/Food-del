# 02. アーキテクチャ設計とコア原則

## 1. 概要

このプロジェクトは、保守性、拡張性、および開発効率を最大化するために、古典的かつ堅牢な**階層型アーキテクチャ（Layered Architecture）** を採用しています。各レイヤーは明確に定義された責務を持ち、関心の分離（Separation of Concerns）が徹底されています。

## 2. 主要なレイヤー

リクエストが処理される流れに沿って、主要なレイヤーを以下に説明します。

### a. `routes/` (ルーティング層)

-   **責務**: APIのエンドポイント（URL）、HTTPメソッド（GET, POSTなど）を定義し、それを担当するコントローラーの関数に結びつけます。
-   **役割**: リクエストの第一関門として、認証（`isAuthenticated`）やデータ検証（`validateBody`）など、後続の処理に必要なミドルウェアを編成します。

```typescript
//例: src/routes/foodRouter.ts

// POST /api/foods/ というエンドポイントを定義
foodRouter.post("/",
        isAdmin, // 1. 権限チェック
        fileUploadMiddleware.single("image"), // 2. ファイルアップロード処理
        handleFileUploadError, // 3. アップロードエラー処理
        validateBody(CreateFoodSchema), // 4. データ検証
        createFood // 5. コントローラー関数へ
);
```

### b. `controllers/` (コントローラー層)

-   **責務**: HTTPリクエストとレスポンスを直接扱います。リクエストからパラメータ（`req.body`, `req.params`）を抽出し、適切なサービス関数を呼び出します。
-   **役割**: 「交通整理員」のように振る舞います。サービス層から返された結果を受け取り、それをクライアント向けのHTTPレスポンス（JSON形式）に整形して送信します。
-   **設計原則**: **シン・コントローラー（Thin Controller）**。ビジネスロジックを一切含まず、プロセスの調整役に徹します。

```typescript
//例: src/controllers/orderController.ts

export const createOrder = async (req, res) => {
    try {
        // 1. リクエストからユーザーIDと配送先情報を取得
        const userId = req.user.id;
        const orderRequestData = req.body;

        // 2. 複雑なビジネスロジックをサービス層に委譲
        const order = await OrderService.createOrderFromCart(userId, orderRequestData);

        // 3. 成功レスポンスを返す
        res.status(201).json({ success: true, data: order });
    } catch (error) {
        // 4. エラーレスポンスを返す
        res.status(500).json({ success: false, message: error.message });
    }
};
```

### c. `services/` (サービス層)

-   **責務**: アプリケーションの**コアビジネスロジック**を実装します。データベース操作、外部APIとの通信、複雑な計算などがここに含まれます。
-   **役割**: アプリケーションの心臓部です。例えば、注文を作成する際には、在庫の確認、合計金額の計算、データベースへの複数テーブルの書き込み（トランザクション処理）、カートのクリアといった一連の処理を責任を持って実行します。
-   **設計原則**: **ファット・サービス（Fat Service）**。関連するビジネスロジックはこのレイヤーに集約されます。

```typescript
//例: src/services/orderService.ts

static async createOrderFromCart(userId, orderRequest) {
    // データベーストランザクションを開始
    return await prisma.$transaction(async (tx) => {
        // 1. カート情報を取得
        // 2. 在庫を検証
        // 3. 合計金額を計算
        // 4. 注文レコードを作成
        // 5. 在庫を更新
        // 6. カートをクリア
        // ...
    });
}
```

## 3. リクエストのライフサイクル

クライアントからのリクエストは、一般的に以下の流れで処理されます。

1.  リクエストが `index.ts` に到達。
2.  グローバルミドルウェア（`helmet`, `cors`, `express.json`など）を通過。
3.  `routes/` 内のルーターによってエンドポイントがマッチングされる。
4.  ルート固有のミドルウェア（`isAuthenticated`, `validateBody`など）が実行される。
5.  `controllers/` の担当関数がリクエストを処理する。
6.  コントローラーが `services/` のメソッドを呼び出し、ビジネスロジックの実行を依頼する。
7.  サービスがPrismaを通じてデータベースと対話し、処理を実行する。
8.  処理結果がコントローラーに返される。
9.  コントローラーが最終的なJSONレスポンスをクライアントに送信する。
10. 途中でエラーが発生した場合、`errorHandler` ミドルウェアがそれを捕捉し、統一されたエラーレスポンスを返す。

## 4. その他の設計原則

-   **型安全性 (Type Safety)**: TypeScriptとZodを全面的に採用し、APIの境界からデータベースの末端まで、データの整合性と安全性を静的に保証します。
-   **一元化された設定**: `lib/env.ts` で環境変数を一元的に検証・管理し、アプリケーション全体で型安全な設定オブジェクトを共有します。
-   **カスタムエラー**: `errors/` ディレクトリでビジネスロジック固有のカスタムエラーを定義し、より意味のあるエラーハンドリングを可能にしています。
