# 07. 共通サービスとミドルウェア

## 1. 概要

このプロジェクトでは、ビジネスロジックをクリーンに保ち、DRY（Don't Repeat Yourself）原則を遵守するために、複数の共通処理が再利用可能なコンポーネントとしてモジュール化されています。ここでは主要な共通コンポーネントについて、その設計と実装を解説します。

## 2. データ検証ミドルウェア (`src/middleware/validation.ts`)

### a. 目的

クライアントからのリクエストデータ（`body`, `query`, `params`）がコントローラーに到達する前に、その構造、型、および制約を検証します。これにより、各コントローラーでの冗長な検証コードを排除し、型安全性を保証します。

### b. 実装

この機能は、`zod`ライブラリと高階関数（関数を返す関数）のパターンを組み合わせて、非常にエレガントに実装されています。

**コード例 (`src/middleware/validation.ts`より):**
```typescript
// Zodスキーマを引数に取り、Expressミドルウェアを返す高階関数
export const validateBody = <T>(schema: z.ZodSchema<T>) => {
    return (req: Request, res: Response, next: NextFunction): void => {
        try {
            // 1. `safeParse`で安全にリクエストボディを検証
            const result = schema.safeParse(req.body);

            // 2. 検証失敗時: 詳細なエラーを含む400レスポンスを返す
            if (!result.success) {
                res.status(400).json({
                    success: false,
                    message: 'リクエストボディの検証に失敗しました',
                    errors: result.error.issues.map(err => ...)
                });
                return;
            }

            // 3. 【重要】検証・型変換済みのデータで`req.body`を上書き
            req.body = result.data;
            next(); // 検証成功、次の処理へ

        } catch (error) {
            // ... (予期せぬエラーの処理)
        }
    };
};
```
`validateQuery`と`validateParams`も同様の構造です。`req.body`を検証済みのデータで上書きすることにより、後続のコントローラーは安全で型が保証されたデータを扱うことができます。

## 3. ファイルアップロード (`src/middleware/fileUpload.ts`)

### a. 目的

`multipart/form-data`形式のリクエストを処理し、アップロードされたファイルを検証してサーバーのディスクに保存します。

### b. 実装

`multer`ライブラリを使用して、ストレージエンジンとファイルフィルタを詳細に設定しています。

**コード例 (`src/middleware/fileUpload.ts`より):**
```typescript
// ストレージエンジンの設定
const storage = diskStorage({
    destination: (_req, file, cb) => {
        // 1. フィールド名に応じて保存先ディレクトリを動的に変更
        let uploadPath = 'storage/public';
        if (file.fieldname === 'avatar') {
            uploadPath = 'storage/private';
        }
        cb(null, uploadPath);
    },
    filename: (_req, file, cb) => {
        // 2. ファイル名をサニタイズして衝突を回避
        const safeName = FileValidator.sanitizeFileName(file.originalname);
        cb(null, safeName);
    }
});

// ファイルフィルタの設定
const fileFilter = (_req, file, cb) => {
    // 3. `FileValidator`を呼び出し、MIMEタイプやサイズを検証
    const validation = FileValidator.validateImage(file);
    if (!validation.isValid) {
        // 検証失敗時はエラーをコールバックに渡す
        return cb(new Error(validation.error));
    }
    cb(null, true); // 検証成功
};

// multerミドルウェア本体
export const fileUploadMiddleware = multer({ storage, fileFilter, limits: { ... } });

// multerが生成するエラーを専門に処理するエラーハンドラ
export const handleFileUploadError: ErrorRequestHandler = (error, req, res, next) => {
    if (error instanceof multer.MulterError) {
        // ファイルサイズ超過などのエラーをハンドリング
        return res.status(400).json({ message: 'ファイルサイズが大きすぎます' });
    }
    // ...
};
```
この実装により、ファイルの物理的な保存処理は、ビジネスロジック（Service層）から完全に分離されています。

## 4. インメモリキャッシュ (`src/utils/simpleCache.ts`)

### a. 目的

頻繁にアクセスされるが、リアルタイム性がそこまで重要でないデータ（例：商品リスト）の応答性能を向上させ、データベースへの負荷を軽減します。

### b. 実装

有効期限（TTL）付きのシンプルなインメモリキャッシュが実装されています。

**コード例 (`src/utils/simpleCache.ts`より):**
```typescript
class SimpleCache {
    private cache = new Map<string, CacheItem<any>>();

    set<T>(key: string, data: T, ttl: number): void {
        // データと有効期限（現在時刻 + TTL）をMapに保存
        this.cache.set(key, { data, expiry: Date.now() + ttl });
    }

    get<T>(key: string): T | null {
        const item = this.cache.get(key);
        if (!item) return null;

        // 有効期限をチェックし、切れていれば削除
        if (Date.now() > item.expiry) {
            this.cache.delete(key);
            return null;
        }
        return item.data as T;
    }

    // パターンに一致するキーのキャッシュを削除（データ更新時に使用）
    deletePattern(pattern: string): number { ... }
}
```

### c. 使い方 (`FoodService`での例)

このキャッシュは、**Cache-Aside Pattern**（キャッシュアサイドパターン）で利用されています。

**コード例 (`src/services/foodService.ts`より):**
```typescript
// 1. クエリパラメータから一意なキャッシュキーを生成
const cacheKey = cache.generateKey('foods_list', { ...query });

// 2. DB問い合わせの前にキャッシュを確認
const cached = cache.get<PaginatedData<FoodData>>(cacheKey);
if (cached) {
    return cached; // キャッシュヒット！DBアクセスを回避
}

// 3. キャッシュがなければDBからデータを取得
const [foods, total] = await Promise.all([ ... ]);

// 4. 取得した結果をキャッシュに保存
cache.set(cacheKey, result, 5 * 60 * 1000); // 5分間キャッシュ

return result;

// --- データ更新時 ---
private static invalidateFoodCache(): void {
    // 5. 関連するキャッシュを無効化
    cache.deletePattern('foods_list');
    cache.deletePattern('foods_count');
}
```
